# Data Model: Full-Stack Web Application (Phase II)

**Feature Branch**: `002-fullstack-web-app`
**Date**: 2025-12-28
**Spec Reference**: [spec.md](./spec.md) §Key Entities

## Entity Relationship Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  ┌──────────────┐           ┌──────────────────────────────┐   │
│  │    User      │           │           Task               │   │
│  ├──────────────┤           ├──────────────────────────────┤   │
│  │ id (PK)      │──────────<│ id (PK)                      │   │
│  │ email        │    1:N    │ user_id (FK) ───────────────►│   │
│  │ name         │           │ title                        │   │
│  │ created_at   │           │ description                  │   │
│  └──────────────┘           │ status                       │   │
│                             │ created_at                   │   │
│                             │ updated_at                   │   │
│                             │ completed_at                 │   │
│                             └──────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Entities

### User

**Purpose**: Represents an authenticated application user.

**Source**: Better Auth (managed externally) + SQLModel (for reference)

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | string | PRIMARY KEY | Unique identifier (UUID from Better Auth) |
| email | string | UNIQUE, NOT NULL, INDEX | User's email address for authentication |
| name | string | NOT NULL | User's display name |
| created_at | timestamp | NOT NULL, DEFAULT NOW() | Account creation timestamp |

**Validation Rules**:
- Email must be valid format (validated by Better Auth)
- Name must be 1-100 characters
- ID is generated by Better Auth (UUID format)

**Notes**:
- User table is managed primarily by Better Auth
- Backend references user_id from JWT token claims
- No password field in our model (Better Auth handles separately)

---

### Task

**Purpose**: Represents a todo item belonging to a specific user.

**Source**: Extended from Phase I `Task` model with `user_id` field.

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | string | PRIMARY KEY | Unique identifier (UUID) |
| user_id | string | FOREIGN KEY → users.id, NOT NULL, INDEX | Owner of the task |
| title | string(200) | NOT NULL, 1-200 chars | Task title |
| description | string(1000) | NULLABLE, max 1000 chars | Optional task description |
| status | enum | NOT NULL, DEFAULT 'pending' | 'pending' or 'completed' |
| created_at | timestamp | NOT NULL, DEFAULT NOW() | Task creation timestamp |
| updated_at | timestamp | NOT NULL, DEFAULT NOW() | Last modification timestamp |
| completed_at | timestamp | NULLABLE | When task was marked complete |

**Validation Rules**:
- Title cannot be empty or whitespace-only (spec FR-020)
- Description is optional but capped at 1000 chars (spec FR-021)
- Status must be 'pending' or 'completed'
- completed_at is set when status changes to 'completed', cleared when 'pending'

**Indexes**:
- `idx_tasks_user_id` on user_id (filter by owner)
- `idx_tasks_status` on status (filter by completion)
- `idx_tasks_user_status` on (user_id, status) (combined filter)

---

## SQLModel Definitions

### File: `src/models/user.py` (NEW)

```python
from datetime import datetime
from sqlmodel import SQLModel, Field

class UserDB(SQLModel, table=True):
    """Database model for users (reference table for Better Auth)."""

    __tablename__ = "users"

    id: str = Field(primary_key=True)
    email: str = Field(unique=True, index=True, max_length=255)
    name: str = Field(max_length=100)
    created_at: datetime = Field(default_factory=lambda: datetime.now(UTC))
```

### File: `src/models/tasks.py` (UPDATED)

```python
from datetime import datetime, UTC
from typing import Literal
from uuid import uuid4
from sqlmodel import SQLModel, Field
from pydantic import field_validator

class TaskDB(SQLModel, table=True):
    """Database model for tasks with user ownership."""

    __tablename__ = "tasks"

    id: str = Field(default_factory=lambda: str(uuid4()), primary_key=True)
    user_id: str = Field(foreign_key="users.id", index=True)
    title: str = Field(max_length=200)
    description: str | None = Field(default=None, max_length=1000)
    status: Literal["pending", "completed"] = Field(default="pending")
    created_at: datetime = Field(default_factory=lambda: datetime.now(UTC))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(UTC))
    completed_at: datetime | None = Field(default=None)

# Keep existing Task (Pydantic) model for API contracts
# TaskDB is for database operations only
```

---

## State Transitions

### Task Status

```
                      mark_complete()
    ┌──────────┐  ─────────────────────>  ┌────────────┐
    │ PENDING  │                          │ COMPLETED  │
    └──────────┘  <─────────────────────  └────────────┘
                      mark_pending()

Invariants:
- completed_at is NULL when status = 'pending'
- completed_at is NOT NULL when status = 'completed'
- updated_at changes on every state transition
```

---

## Migration from Phase I

### Changes Required

1. **Task Model**: Add `user_id` field (required, foreign key)
2. **StorageBackend Protocol**: Add optional `user_id` parameter to `query()` and `get_all()`
3. **TaskManagerAgent**: Accept `user_id` in all action payloads
4. **New Models**: Create `UserDB` for database representation

### Backward Compatibility

- Phase I console app continues using in-memory backend
- In-memory backend ignores `user_id` filter (returns all tasks)
- Web API uses PostgreSQL backend with user filtering
- Same `Task` Pydantic model used for both interfaces

---

## Database Schema SQL

```sql
-- Users table (Better Auth compatibility)
CREATE TABLE users (
    id VARCHAR(36) PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    name VARCHAR(100) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Tasks table with user ownership
CREATE TABLE tasks (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(200) NOT NULL,
    description TEXT,
    status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'completed')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Indexes for performance
CREATE INDEX idx_tasks_user_id ON tasks(user_id);
CREATE INDEX idx_tasks_status ON tasks(status);
CREATE INDEX idx_tasks_user_status ON tasks(user_id, status);
```

---

## API ↔ Database Model Mapping

| API Model (Pydantic) | DB Model (SQLModel) | Conversion |
|---------------------|---------------------|------------|
| Task.id | TaskDB.id | Direct copy |
| Task.title | TaskDB.title | Direct copy |
| Task.description | TaskDB.description | Direct copy |
| Task.status | TaskDB.status | Direct copy |
| Task.created_at | TaskDB.created_at | Direct copy |
| Task.updated_at | TaskDB.updated_at | Direct copy |
| Task.completed_at | TaskDB.completed_at | Direct copy |
| (N/A in Phase I) | TaskDB.user_id | Added from auth context |

**Conversion Functions**:
```python
def task_to_db(task: Task, user_id: str) -> TaskDB:
    return TaskDB(user_id=user_id, **task.model_dump())

def db_to_task(db_task: TaskDB) -> Task:
    return Task(**db_task.model_dump(exclude={"user_id"}))
```
